using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;
using Mono.Cecil.Cil;
using TinyIoC;
using SR = System.Reflection;

namespace Rest.Fody.Weaving
{
    internal sealed class ClassWeaver : Weaver
    {
        #region References
        // types
        private TypeReference HttpClientRef;
        private TypeReference HttpHeadersRef;
        private TypeReference UriRef;
        private TypeReference HttpMethodRef;

        // constructors
        private MethodReference HttpClient_Ctor;
        private MethodReference Uri_Ctor;

        // methods
        private MethodReference BaseAddress_Set;
        private MethodReference DefaultHeaders_Get;
        private MethodReference HttpHeaders_Add;
        private MethodReference HttpClient_Dispose;

        public override void ImportNecessaryReferences()
        {
            // references
            HttpClientRef = Module.ImportType<HttpClient>();
            HttpHeadersRef = Module.ImportType<HttpHeaders>();
            HttpMethodRef = Module.ImportType<HttpMethod>();
            UriRef = Module.ImportType<Uri>();
            
            // constructors
            HttpClient_Ctor = Module.ImportCtor<HttpClient>();
            Uri_Ctor = Module.ImportCtor<Uri>(typeof(string));
            
            // properties
            BaseAddress_Set = Module.ImportSetter<HttpClient, Uri>(x => x.BaseAddress);
            DefaultHeaders_Get = Module.ImportGetter<HttpClient, HttpRequestHeaders>(x => x.DefaultRequestHeaders);
            
            // methods
            HttpHeaders_Add = Module.ImportMethod<HttpHeaders>(nameof(HttpHeaders.Add), typeof(string), typeof(string));
            HttpClient_Dispose = Module.ImportMethod<HttpClient>(nameof(HttpClient.Dispose));
        }
        #endregion

        public event Action<TypeDefinition> RegisteredClass;

        public void RunType(TypeDefinition type)
        {
            Uri baseAddress;
            MethodDefinition httpClientGetter;
            bool autogenerated = false;
            Dictionary<string, string> headers = null;

            if (TryGetServiceAttr(type, out baseAddress))
            {
                // we do this either way, since [RestClient] overrides a custom HttpClient
                if (!TryGetRestClientAttr(type, out httpClientGetter) && baseAddress == null)
                    throw type.Message("No base address was given, and no HttpClient marked [RestClient] could be found.");

                // add headers on empty client getter, or the option is set
                if (httpClientGetter == null || Options.AddHeadersToAlreadyExistingHttpClient)
                    headers = ResolveHeaders(type).ToDictionary(x => x.Key, x => x.Value);

                if (httpClientGetter == null) // create client if needed
                {
                    httpClientGetter = Logger.Region("GENERATING HTTP CLIENT", () => GenerateHttpClientGetter(type, baseAddress, headers));
                    autogenerated = true;
                }
                else if (Options.AddHeadersToAlreadyExistingHttpClient) // or add headers to user if asked for
                    AddHeadersToClient(type, headers);

                if (autogenerated && type.Interfaces.Any(x => x.Is<IDisposable>()))
                    HookDispose(type.Methods.First(x => x.Name == "Dispose" && x.Parameters.Count == 0), httpClientGetter);

                // generate methods
                for (int i = 0; i < type.Methods.Count; i++)
                    Container.Resolve<MethodWeaver>().RunMethod(type.Methods[i], httpClientGetter);

                RegisteredClass?.Invoke(type);
            }
        }

        private void HookDispose(MethodDefinition dispose, MethodDefinition httpClientGetter)
        {
            // we want to insert this BEFORE return.
            dispose.Body.EmitManyBefore(1,
                Instruction.Create(OpCodes.Ldarg_0),
                Instruction.Create(OpCodes.Callvirt, httpClientGetter),
                Instruction.Create(OpCodes.Callvirt, HttpClient_Dispose)
                );
        }

        private void AddHeadersToClient(TypeDefinition t, IDictionary<string, string> headers)
        {
            foreach (var ctor in t.Methods.Where(x => x.IsConstructor))
            {
                List<Instruction> instructions = new List<Instruction>
                {
                        Instruction.Create(OpCodes.Ldarg_0),
                        Instruction.Create(OpCodes.Newobj, HttpClient_Ctor),        // get http client
                        Instruction.Create(OpCodes.Nop)
                };

                foreach (var header in headers)
                {
                    instructions.Add(Instruction.Create(OpCodes.Dup));
                    instructions.Add(Instruction.Create(OpCodes.Callvirt, DefaultHeaders_Get));

                    instructions.Add(Instruction.Create(OpCodes.Ldstr, header.Key));          // push header name to stack
                    instructions.Add(Instruction.Create(OpCodes.Ldstr, header.Value));        // push header value to stack
                    instructions.Add(Instruction.Create(OpCodes.Callvirt, HttpHeaders_Add));  // call Add() on DefaultHttpHeaders

                    instructions.Add(Instruction.Create(OpCodes.Nop));
                }

                ctor.Body.EmitMany(instructions);
            }
        }

        private MethodDefinition GenerateHttpClientGetter(TypeDefinition t, Uri baseAddr, IDictionary<string, string> headers)
        {
            const string GENERATED_HTTP_CLIENT_NAME = "autoGeneratedHttpClient";

            Logger.Log("Generating field", false);

            // create holding field
            FieldDefinition field = new FieldDefinition($"${GENERATED_HTTP_CLIENT_NAME}", FieldAttributes.Private, HttpClientRef);
            t.Fields.Add(field);

            Logger.Log("Generating field getter", false);

            var getter = new MethodDefinition($"get_${GENERATED_HTTP_CLIENT_NAME}", MethodAttributes.Private, HttpClientRef);
            getter.Body.Emit(il =>
            {
                il.Emit(OpCodes.Ldarg_0);       // this
                il.Emit(OpCodes.Ldfld, field);  // this.[field] -> stack
                il.Emit(OpCodes.Ret);           // return stack
            });

            t.Methods.Add(getter);

            // add instructions to create httpclient to constructor
            Logger.Log("Generating HttpClient field initializer in constructors", false);
            foreach (var ctor in t.Methods.Where(x => x.IsConstructor))
            {
                List<Instruction> instructions = new List<Instruction>
                {
                        Instruction.Create(OpCodes.Ldarg_0),
                        Instruction.Create(OpCodes.Newobj, HttpClient_Ctor),        // create http client
                        Instruction.Create(OpCodes.Dup),

                        Instruction.Create(OpCodes.Ldstr, baseAddr.OriginalString), // load str to stack
                        Instruction.Create(OpCodes.Newobj, Uri_Ctor),               // create uri
                        Instruction.Create(OpCodes.Callvirt, BaseAddress_Set),      // set BaseAddress

                        Instruction.Create(OpCodes.Nop)
                };

                foreach (var header in headers)
                {
                    instructions.Add(Instruction.Create(OpCodes.Dup));
                    instructions.Add(Instruction.Create(OpCodes.Callvirt, DefaultHeaders_Get));

                    instructions.Add(Instruction.Create(OpCodes.Ldstr, header.Key));          // push header name to stack
                    instructions.Add(Instruction.Create(OpCodes.Ldstr, header.Value));        // push header value to stack
                    instructions.Add(Instruction.Create(OpCodes.Callvirt, HttpHeaders_Add));  // call Add() on DefaultHttpHeaders

                    instructions.Add(Instruction.Create(OpCodes.Nop));
                }

                instructions.Add(Instruction.Create(OpCodes.Stfld, field));

                ctor.Body.EmitToBeginning(instructions.ToArray());
            }

            return getter;
        }

        private IEnumerable<KeyValuePair<string, string>> ResolveHeaders(TypeDefinition t)
        {
            foreach (CustomAttribute a in t.GetAttrs<HeaderAttribute>())
            {
                string[] header = a.ConstructorArguments.Select(x => x.Value as string).ToArray();

                if (a.ConstructorArguments.Any(x => x.Value == null))
                    throw t.Message("[Header] cannot have a null value.");
                else if (a.ConstructorArguments.Count != 2)
                    throw t.Message("[Header] on a class must have two values.");
                else
                    yield return new KeyValuePair<string, string>(
                        (string)a.ConstructorArguments[0].Value,
                        (string)a.ConstructorArguments[0].Value);
            }
        }

        private bool TryGetRestClientAttr(TypeDefinition t, out MethodDefinition httpClientGetter)
        {
            httpClientGetter = null;

            PropertyDefinition p = (from prop in t.Properties
                                    let attr = prop.GetAttr<RestClientAttribute>()
                                    where attr != null
                                    select prop).FirstOrDefault();

            if (p == null)
                return false;

            if (!p.PropertyType.Is<HttpClient>())
                throw t.Message("[RestClient] can only be set on HttpClient properties.");
            if (p.GetMethod == null)
                throw t.Message("[RestClient] must have a getter.");
            if (p.GetMethod.IsStatic)
                throw t.Message("[RestClient] mustn't be static.");

            httpClientGetter = p.GetMethod;
            return true;
        }

        private bool TryGetServiceAttr(TypeDefinition t, out Uri baseAddress)
        {
            baseAddress = null;

            if (t.Name == "<Module>")
                return false;

            CustomAttribute a = t.GetAttr<ServiceForAttribute>();

            if (a == null)
            {
                a = t.GetAttr<ServiceAttribute>();

                if (a == null)
                    return false;

                return true;
            }

            string addr = (string)a.ConstructorArguments[0].Value;

            if (addr != null && Uri.TryCreate(addr, UriKind.Absolute, out baseAddress)) // address provided
                return true;
            else // address provided, but invalid
                throw t.Message($"The base address provided for the type {t.Name} was invalid.");
        }
    }
}
